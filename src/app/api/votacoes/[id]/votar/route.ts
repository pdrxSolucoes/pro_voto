import { NextRequest, NextResponse } from "next/server";
import { Votacao } from "@/server/entities/Votacao";
import { Voto } from "@/server/entities/Voto";
import { Usuario } from "@/server/entities/Usuario";
import { Projeto } from "@/server/entities/Projeto";
import { AppDataSource } from "@/lib/db/datasource";

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const votacaoId = parseInt(params.id);

    if (isNaN(votacaoId)) {
      return NextResponse.json(
        { error: "ID de vota√ß√£o inv√°lido" },
        { status: 400 }
      );
    }

    console.log(`üó≥Ô∏è Tentando registrar voto na vota√ß√£o ID: ${votacaoId}`);

    // Garantir que a conex√£o com o banco est√° ativa
    if (!AppDataSource.isInitialized) {
      await AppDataSource.initialize();
    }

    // Usar os reposit√≥rios da nova API do TypeORM
    const votacaoRepository = AppDataSource.getRepository(Votacao);
    const votoRepository = AppDataSource.getRepository(Voto);
    const usuarioRepository = AppDataSource.getRepository(Usuario);
    const projetoRepository = AppDataSource.getRepository(Projeto);

    // Verificar se a vota√ß√£o existe e est√° em andamento
    const votacao = await votacaoRepository.findOne({
      where: { id: votacaoId, resultado: "em_andamento" },
      relations: ["projeto"],
    });

    if (!votacao) {
      console.log(`‚ùå Vota√ß√£o ${votacaoId} n√£o encontrada ou j√° finalizada`);
      return NextResponse.json(
        { error: "Vota√ß√£o n√£o encontrada ou j√° finalizada" },
        { status: 404 }
      );
    }

    // Obter dados do corpo da requisi√ß√£o
    const body = await request.json();

    // Extrair dados, suportando tanto vereador_id quanto vereadorId
    const vereador_id = body.vereador_id || body.vereadorId;
    const voto = body.voto;

    console.log(`üìù Dados recebidos:`, {
      vereador_id,
      voto,
      votacao_id: votacaoId,
    });

    // Validar dados
    if (!vereador_id || !voto) {
      return NextResponse.json({ error: "Dados incompletos" }, { status: 400 });
    }

    // Verificar se o voto √© v√°lido
    if (!["aprovar", "desaprovar", "abster"].includes(voto)) {
      return NextResponse.json({ error: "Voto inv√°lido" }, { status: 400 });
    }

    // Verificar se o vereador existe
    const usuario = await usuarioRepository.findOne({
      where: [
        { id: vereador_id, cargo: "vereador", ativo: true },
        { id: vereador_id, cargo: "admin", ativo: true },
      ],
    });
    console.log("√∫suario", usuario);
    if (!usuario) {
      console.log(`‚ùå Vereador ${vereador_id} n√£o encontrado ou inativo`);
      return NextResponse.json(
        { error: "Vereador n√£o encontrado" },
        { status: 404 }
      );
    }

    // Verificar se o vereador j√° votou nesta vota√ß√£o
    const votoExistente = await votoRepository.findOne({
      where: {
        votacao: { id: votacaoId }, // Usando relacionamento
        vereador: { id: vereador_id }, // Usando relacionamento
      },
    });

    if (votoExistente) {
      console.log(
        `‚ö†Ô∏è Vereador ${vereador_id} j√° votou na vota√ß√£o ${votacaoId}`
      );
      return NextResponse.json(
        { error: "Vereador j√° votou nesta vota√ß√£o" },
        { status: 409 }
      );
    }

    // Usar QueryRunner para transa√ß√£o
    const queryRunner = AppDataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // Registrar o voto
      const novoVoto = queryRunner.manager.create(Voto, {
        votacao: votacao,
        vereador: usuario,
        voto: voto,
        dataVoto: new Date(),
      });

      await queryRunner.manager.save(novoVoto);
      console.log(`‚úÖ Voto registrado com sucesso:`, { id: novoVoto.id, voto });

      // Buscar contagem atualizada de votos
      const totalVotos = await queryRunner.manager.count(Voto, {
        where: { votacao: { id: votacaoId } },
      });

      // Buscar total de vereadores ativos
      const totalVereadores = await queryRunner.manager.count(Usuario, {
        where: { cargo: "vereador", ativo: true },
      });

      console.log(
        `üìä Progresso da vota√ß√£o: ${totalVotos}/${totalVereadores} votos`
      );

      // Se todos votaram, finalizar automaticamente a vota√ß√£o
      if (totalVotos >= totalVereadores) {
        console.log(`üèÅ Finalizando vota√ß√£o automaticamente - todos votaram`);

        // Buscar todos os votos para contagem
        const todosVotos = await queryRunner.manager.find(Voto, {
          where: { votacao: { id: votacaoId } },
        });

        // Contar votos por categoria
        const votosFavor = todosVotos.filter(
          (v: any) => v.voto === "aprovar"
        ).length;
        const votosContra = todosVotos.filter(
          (v: any) => v.voto === "desaprovar"
        ).length;
        const abstencoes = todosVotos.filter(
          (v: any) => v.voto === "abster"
        ).length;

        // Determinar resultado
        const resultado = votosFavor > votosContra ? "aprovada" : "reprovada";

        console.log(`üìà Resultado da vota√ß√£o:`, {
          favor: votosFavor,
          contra: votosContra,
          abstencoes: abstencoes,
          resultado: resultado,
        });

        // Atualizar vota√ß√£o
        await queryRunner.manager.update(Votacao, votacaoId, {
          resultado: resultado,
          dataFim: new Date(),
          votosFavor: votosFavor,
          votosContra: votosContra,
          abstencoes: abstencoes,
        });

        // Atualizar status do projeto se existir
        if (votacao.projeto) {
          await queryRunner.manager.update(Projeto, votacao.projeto.id, {
            status: resultado,
          });
          console.log(`üìã Status do projeto atualizado para: ${resultado}`);
        }

        await queryRunner.commitTransaction();

        return NextResponse.json({
          success: true,
          votacao_finalizada: true,
          resultado: resultado,
          contagem: {
            favor: votosFavor,
            contra: votosContra,
            abstencoes: abstencoes,
            total: totalVotos,
          },
        });
      } else {
        // Atualizar contadores parciais na vota√ß√£o
        const votosParciais = await queryRunner.manager.find(Voto, {
          where: { votacao: { id: votacaoId } },
        });

        const votosFavorParcial = votosParciais.filter(
          (v: any) => v.voto === "aprovar"
        ).length;
        const votosContraParcial = votosParciais.filter(
          (v: any) => v.voto === "desaprovar"
        ).length;
        const abstencoesParcial = votosParciais.filter(
          (v: any) => v.voto === "abster"
        ).length;

        await queryRunner.manager.update(Votacao, votacaoId, {
          votosFavor: votosFavorParcial,
          votosContra: votosContraParcial,
          abstencoes: abstencoesParcial,
        });

        console.log(`üìä Contadores atualizados:`, {
          favor: votosFavorParcial,
          contra: votosContraParcial,
          abstencoes: abstencoesParcial,
        });

        await queryRunner.commitTransaction();

        return NextResponse.json({
          success: true,
          votacao_finalizada: false,
          progresso: {
            votos_registrados: totalVotos,
            total_vereadores: totalVereadores,
            restam: totalVereadores - totalVotos,
          },
        });
      }
    } catch (transactionError) {
      await queryRunner.rollbackTransaction();
      throw transactionError;
    } finally {
      await queryRunner.release();
    }
  } catch (error) {
    console.error("‚ùå Erro ao registrar voto:", error);

    // Log detalhado do erro
    if (error instanceof Error) {
      console.error("Error name:", error.name);
      console.error("Error message:", error.message);
      console.error("Error stack:", error.stack);
    }

    // Verificar se √© erro de constraint √∫nica (vereador j√° votou)
    if (
      error instanceof Error &&
      (error.message.includes("unique constraint") ||
        error.message.includes("duplicate key") ||
        error.message.includes("UNIQUE constraint failed"))
    ) {
      return NextResponse.json(
        { error: "Vereador j√° votou nesta vota√ß√£o" },
        { status: 409 }
      );
    }

    // Verificar se √© erro de conex√£o
    if (
      error instanceof Error &&
      (error.message.includes("connection") ||
        error.message.includes("ECONNREFUSED") ||
        error.message.includes("database"))
    ) {
      return NextResponse.json(
        {
          success: false,
          error: "Erro de conex√£o com o banco de dados",
          details:
            process.env.NODE_ENV === "development"
              ? error.message
              : "Erro de conex√£o",
        },
        { status: 503 }
      );
    }

    // Verificar se √© erro de inicializa√ß√£o do TypeORM
    if (error instanceof Error && error.message.includes("DataSource")) {
      return NextResponse.json(
        {
          success: false,
          error: "Erro de inicializa√ß√£o do banco de dados",
          details:
            process.env.NODE_ENV === "development"
              ? error.message
              : "Erro de configura√ß√£o",
        },
        { status: 503 }
      );
    }

    return NextResponse.json(
      {
        success: false,
        error: "Erro interno do servidor",
        details:
          process.env.NODE_ENV === "development"
            ? error instanceof Error
              ? error.message
              : "Erro desconhecido"
            : "Erro ao registrar voto",
      },
      { status: 500 }
    );
  }
}
